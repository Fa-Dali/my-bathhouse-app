Делаю приложение Next.js (TipeScript) + Django + PostgreSQL_16.
ЗАДАЧА: На фронтенде надо сделать страницу регистрации пользователя и отправить уже в настроенную БД PostgreSQL_16.

ПОСМОТРИ ВСЁ ЛИ ПРАВИЛЬНО И НУЖНО?
У меня есть такие файлы бэкенде Django:


backend/env/...


backend/media/...


backend/my_bathhouse_backend/apps/users/migrations/0001_initial.py

# Generated by Django 5.2.7 on 2025-10-03 23:55
# my_bathhouse_backend/apps/migrations/0001_initial.py
import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('phone_number', models.CharField(blank=True, max_length=15, null=True)),
                ('pin_code', models.CharField(blank=True, max_length=5, null=True)),
                ('avatar', models.ImageField(blank=True, null=True, upload_to='avatars/')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
===============================
backend/my_bathhouse_backend/apps/users/migrations/__init__.py
ПУСТОЙ
===============================
backend/my_bathhouse_backend/apps/users/__init__.py
ПУСТОЙ

===============================
backend/my_bathhouse_backend/apps/users/admin.py
from django.contrib import admin

# Register your models here.
===============================
backend/my_bathhouse_backend/apps/users/api_views.py
'''
Содержит представление (API view), которое будет принимать данные
от фронтенда и сохранять их в базу данных.
'''


from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .serializers import UserSerializer

class RegisterAPI(APIView):
    def post(self, request, format=None):
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Пользователь успешно зарегистрирован"},
                            status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

===============================
backend/my_bathhouse_backend/apps/users/apps.py
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'my_bathhouse_backend.apps.users'

===============================
backend/my_bathhouse_backend/apps/users/forms.py
from django import forms
from .models import User

class RegistrationForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput())

    class Meta:
        model = User
        fields = ['first_name',
                  'last_name',
                  'username',
                  'email',
                  'phone_number',
                  'telegram_username',
                  'max_account_id']

    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data["password"])
        if commit:
            user.save()
        return user

===============================
backend/my_bathhouse_backend/apps/users/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    phone_number = models.CharField(max_length=15, null=True, blank=True)
    pin_code = models.CharField(max_length=5, null=True, blank=True)
      # Место хранения картинок и опции
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)

# Create your models here.

===============================
backend/my_bathhouse_backend/apps/users/serializers.py
'''
Для преобразования данных из формата фронтенда в формат, подходящий
для Django и наоборот
'''

from rest_framework import serializers
from .models import CustomUser

class UserSerializer(serializers.ModelSerializer):

    # Сделаем поле аватара необязательным
    avatar = serializers.ImageField(required=False)

    class Meta:
        model = CustomUser
        fields = [
            'id',
            'username',
            'first_name',
            'last_name',
            'email',
            'password',
            'phone_number',
            'pin_code',
            'avatar'
        ]
        # Пароль доступен только для записи
        extra_kwargs = {'password': {'write_only': True}, 'avatar': {'required': False}}

    # ========================
    def validate_first_name(self, value):
        if not value.strip():  # Убедись, что имя не пустое
            raise serializers.ValidationError("First Name cannot be empty.")
        return value

    def validate_last_name(self, value):
        if not value.strip():  # То же для фамилии
            raise serializers.ValidationError("Last Name cannot be empty.")
        return value
    # =========================

    def create(self, validated_data):
        # Извлекаем файл, если он есть
        avatar = validated_data.pop('avatar', None)

        user = CustomUser.objects.create_user(
            # Обязательное поле username - логин
            username=validated_data.get('username'),

            first_name=validated_data.get('first_name'),
            last_name=validated_data.get('last_name'),
            email=validated_data.get('email'),
            password=validated_data.get('password'),
            phone_number=validated_data.get('phone_number'),
            pin_code=validated_data.get('pin_code'),
        )

        if avatar:  # Если аватар был отправлен, добавляем его пользователю
            user.avatar = avatar
            user.save(update_fields=['avatar'])

        return user

===============================
backend/my_bathhouse_backend/apps/users/tests.py
from django.test import TestCase

# Create your tests here.

===============================
backend/my_bathhouse_backend/apps/users/urls.py
'''
Настраивает маршруты для доступа к API, чтобы фронтенд мог отправлять данные.
'''
from django.urls import path
from .api_views import RegisterAPI

urlpatterns = [
    path('register/', RegisterAPI.as_view(), name='register_api'),
]

===============================
backend/my_bathhouse_backend/apps/users/views.py
from django.shortcuts import render

# Create your views here.

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
# from .serializers import RegistrationSerializer
from .serializers import UserSerializer

class RegisterAPI(APIView):
    def post(self, request, *args, **kwargs):
        # serializer = RegistrationSerializer(data=request.data)
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Registration successful"},
                            status=status.HTTP_201_CREATED)
        return Response(serializer.errors,
                        status=status.HTTP_400_BAD_REQUEST)

===============================
backend/my_bathhouse_backend/apps/__init__.py
ПУСТОЙ

===============================
backend/my_bathhouse_backend/__init__.py
ПУСТОЙ

===============================
backend/my_bathhouse_backend/asgi.py
"""
ASGI config for my_bathhouse_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_bathhouse_backend.settings')

application = get_asgi_application()

===============================
# my_bathhouse_backend/settings.py
import os
from pathlib import Path

# from django.conf.global_settings import AUTH_USER_MODEL

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Определяем папку для медиа файлов (если нужно, можно заменить)
MEDIA_ROOT = os.path.join(BASE_DIR, 'media/')

# URL для обслуживания медиа файлов
MEDIA_URL = '/media/'


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-bd2td8c*d9pyy3^8$%oko6%ng#=w7_-)x))u2j2kqa&(*@2@-n'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# ALLOWED_HOSTS = ['bathhouse-app.ru', 'www.bathhouse-app.ru']
# ALLOWED_HOSTS = ['localhost', '127.0.0.1']
# ['localhost', '127.0.0.1']: Эти два адреса означают, что приложение
#   примет запросы только с локальных машин (например, при разработке).
#   Когда вы развертываете сайт публично, вам потребуется добавить
#   реальные домены, на которых ваше приложение размещено
#   (например, example.com, www.example.com).
ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'my_bathhouse_backend.apps.users.apps.UsersConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'corsheaders',
    'rest_framework',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',  # фронтенд на localhost:3000
]

ROOT_URLCONF = 'my_bathhouse_backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'my_bathhouse_backend.wsgi.application'

ASGI_APPLICATION = 'my_bathhouse_backend.asgi.application'

# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'bathhouse_db',       # Название базы данных
        'USER': 'bathhouse_user',     # Пользователь PostgreSQL
        'PASSWORD': 'strongpassword', # Пароль пользователя
        'HOST': 'localhost',          # Локальный хост
        'PORT': '5432',               # Стандартный порт
    }
}

# =========================
# Активируйте ведение журнала запросов в Django,
# чтобы видеть подробности SQL-запросов и ошибок:

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
            'handlers': ['console'],
        },
    },
}
# =========================

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

AUTH_USER_MODEL = 'my_bathhouse_backend.apps.users.RegistrationUser'

# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# =========================
# Активируйте ведение журнала запросов в Django,
# чтобы видеть подробности SQL-запросов и ошибок:

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
            'handlers': ['console'],
        },
    },
}
# =========================

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

AUTH_USER_MODEL = 'users.CustomUser'

# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

===============================
backend/my_bathhouse_backend/urls.py
"""
Конфигурация URL для проекта my_bathhouse_backend.

Список `urlpatterns` направляет URL-адреса к представлениям (views.py).
Для получения дополнительной информации смотри.:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Например:
Функции views.py
    1. Добавить импорт:  from my_bathhouse_backend import views
    2. Добавьте URL в urlpatterns:  path('', views.home, name='home')
Class-based (основной класс) views.py
    1. Добавить импорт:  from other_app.views import Home
    2. Добавьте URL в urlpatterns:  path('', Home.as_view(), name='home')
Включая другую конфигурацию URL
    1. Импортируйте функцию include(): from django.urls import include, path
    2. Добавьте URL в urlpatterns:  path('blog/', include('blog.urls'))
"""
# my_bathhouse_backend/urls.py

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from .views import home


urlpatterns = [
    # Главная страница
    path('', home, name='home'),
    path('admin/', admin.site.urls),
    # Включаем маршруты нашего приложения
    path('api/', include('my_bathhouse_backend.apps.users.urls')),
]

# Добавляем маршрут для обслуживания медиа файлов
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

===============================
backend/my_bathhouse_backend/views.py
from django.http import HttpResponse

def home(request):
    return HttpResponse("Добро пожаловать на мой сайт бань!")

===============================
backend/my_bathhouse_backend/wsgi.py
"""
WSGI config for my_bathhouse_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_bathhouse_backend.settings')

application = get_wsgi_application()

===============================
backend/__init__.py
ПУСТОЙ

===============================
backend/manage.py
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_bathhouse_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


==================================
Все что установлено на фронтенде:
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        12.10.2025      4:02                .bin
d-----        12.10.2025      4:02                .pnpm
d-----        08.10.2025     21:11                @heroicons
d-----        08.10.2025     21:11                @tailwindcss
d-----        12.10.2025      4:02                @tanstack
d-----        08.10.2025     21:11                @types
d----l        08.10.2025     21:11                autoprefixer
d----l        12.10.2025      4:02                axios
d----l        08.10.2025     21:11                bcrypt
d----l        08.10.2025     21:11                clsx
d----l        08.10.2025     21:11                next
d----l        08.10.2025     21:11                next-auth
d----l        08.10.2025     21:11                postcss
d----l        08.10.2025     21:11                postgres
d----l        08.10.2025     21:11                react
d----l        08.10.2025     21:11                react-dom
d----l        12.10.2025      4:02                react-hook-form
d----l        08.10.2025     21:11                tailwindcss
d----l        08.10.2025     21:11                typescript
d----l        08.10.2025     21:11                use-debounce
d----l        08.10.2025     21:11                zod
-a----        12.10.2025      4:02          11128 .modules.yaml
-a----        12.10.2025      4:02            607 .pnpm-workspace-state-v1.json




